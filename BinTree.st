Object subclass: #BinTree	instanceVariableNames: 'root'	classVariableNames: ''	poolDictionaries: ''	category: 'BinTree'!!BinTree methodsFor: 'tests' stamp: 'YeCheng 3/1/2014 13:21'!testNode	"test inorder, preorder and postordertraversal of the tree using recursion"	| node1 node2 node3 binTree|	node1 := Node new: 'A'.	node2:= Node new:'C'.	node3:= Node new:'B'.	node1 addLeftKid: node2.	node2 addRightKid: node3.	binTree:= BinTree new: node1.	Transcript show:'InOrder Traversal of the tree is: '.	binTree inOrder:(binTree getRoot).	Transcript cr.	Transcript show:'PreOrder Traversal of the tree is: '.	binTree preOrder:(binTree getRoot).	Transcript cr.	Transcript show:'PostOrder Traversal of the tree is: '.	binTree postOrder:(binTree getRoot).	Transcript cr.! !!BinTree methodsFor: 'traversal' stamp: 'YeCheng 3/1/2014 13:19'!inOrder: rootNode	"inorder using recursion"		rootNode notNil ifTrue: [ 		self inOrder:(rootNode getLeftKid). 		rootNode printLabel.		self inOrder:(rootNode getRightKid)		]! !!BinTree methodsFor: 'traversal' stamp: 'YeCheng 3/1/2014 13:19'!postOrder: rootNode	"postorder traversal using recursion "		rootNode notNil ifTrue: [ 				self postOrder:(rootNode getLeftKid). 		self postOrder:(rootNode getRightKid).		rootNode printLabel		]! !!BinTree methodsFor: 'initialization' stamp: 'YeCheng 3/1/2014 13:19'!getRoot	"return the root of the root "	^root! !!BinTree methodsFor: 'initialization' stamp: 'YeCheng 3/1/2014 13:20'!preOrder: rootNode	"preorder traversal using recursion"		rootNode notNil ifTrue: [ 				rootNode printLabel.		self preOrder:(rootNode getLeftKid). 		self preOrder:(rootNode getRightKid)		]! !!BinTree methodsFor: 'initialization' stamp: 'YeCheng 3/1/2014 13:20'!setRoot: aNode	"set node to be the root of the tree"	root:=aNode! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!BinTree class	instanceVariableNames: ''!!BinTree class methodsFor: 'as yet unclassified' stamp: 'YeCheng 2/28/2014 13:31'!new: aNode	"make a new tree"		^super new	setRoot:aNode! !Object subclass: #InorderTraversal	instanceVariableNames: 'stack aBinTree node0'	classVariableNames: ''	poolDictionaries: ''	category: 'BinTree'!!InorderTraversal methodsFor: 'traversal' stamp: 'YeCheng 3/2/2014 13:58'!first	"push the root of the tree to the stack, if the left kid of the root is not empty, keep pushing its left kid into 	the stack, until reaching the leftmost node"	|tempNode|	stack push: (node0:=Node new: '0'). 	tempNode:= aBinTree getRoot.	"use a node 0 to indicate the bottom of the stack"	[tempNode notNil] whileTrue: [ 			stack push: tempNode.						tempNode := tempNode getLeftKid.		 ].	^stack top			! !!InorderTraversal methodsFor: 'traversal' stamp: 'YeCheng 3/1/2014 13:26'!inorder	"inorder traversal of the tree"	|tempNode|	Transcript cr.	Transcript show: 'Inorder Traversal of the tree (by stack): '.	tempNode :=self first.	[tempNode notNil] whileTrue:[		tempNode printLabel.		tempNode :=self next	]	! !!InorderTraversal methodsFor: 'traversal' stamp: 'YeCheng 3/2/2014 14:12'!next	"get the next element of the top node, if it has right kid, keep pushing the left brach of the right kid into the stack, until reach the leftmost of the right kid"	| returnNode tempNode |	     (stack top) == node0 ifFalse: [ 		returnNode:= stack pop.		returnNode getRightKid notNil ifTrue: [ 				tempNode := returnNode getRightKid.				[tempNode notNil] whileTrue: [ 					stack push: tempNode.					tempNode:= tempNode getLeftKid				 ]			 ].		stack top == node0 ifTrue: [ ^ nil ] ifFalse: [ ^ stack top. ]	 ]	ifTrue: [ ^nil ]! !!InorderTraversal methodsFor: 'testing' stamp: 'YeCheng 3/2/2014 14:13'!testInorder	"create a tree, do inorder traversal using first and next"	"Test case #1"	| node1 node2 node3 node4 binTree traversal node5 node6 node7 node8 node9 |	node1 := Node new: 'A'.	node2:= Node new:'C'.	node3:= Node new:'B'.	node4 := Node new:'D'.	node5 := Node new:'E'.	node6 := Node new:'F'.	node7 := Node new:'G'.	node8 := Node new:'H'.	node9 := Node new:'I'.	node1 addLeftKid: node2.	node2 addRightKid: node3.	node2 addLeftKid: node4.	node4 addLeftKid: node5.	node1 addRightKid: node6.	node6 addLeftKid: node7.	node6 addRightKid: node8.	node8 addRightKid: node9.	binTree:= BinTree new: node1.		traversal:= InorderTraversal new:binTree.	traversal inorder! !!InorderTraversal methodsFor: 'testing' stamp: 'YeCheng 3/2/2014 14:13'!testInorder2	"create a tree, do inorder traversal using first and next"	"Test case #2"	| node1 node2 node3 binTree traversal |	node1 := Node new: 'A'.	node2:= Node new:'C'.	node3:= Node new:'B'.	node1 addLeftKid: node2.	node2 addRightKid: node3.	binTree:= BinTree new: node1.		traversal:= InorderTraversal new:binTree.	traversal inorder! !!InorderTraversal methodsFor: 'initialization' stamp: 'YeCheng 3/2/2014 13:57'!setStack:aTree	"get the root of the tree, and push the root into a new empty stack"	aBinTree := aTree.	stack:= Stack new.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!InorderTraversal class	instanceVariableNames: ''!!InorderTraversal class methodsFor: 'as yet unclassified' stamp: 'YeCheng 3/1/2014 09:43'!new: aBinTree	"comment stating purpose of message"	^super new 	setStack: aBinTree 	! !Object subclass: #Node	instanceVariableNames: 'label leftKid rightKid'	classVariableNames: ''	poolDictionaries: ''	category: 'BinTree'!!Node methodsFor: 'kidOperation' stamp: 'YeCheng 2/28/2014 14:47'!addLeftKid: aNode	"add the left child to a node"	leftKid:= aNode! !!Node methodsFor: 'kidOperation' stamp: 'YeCheng 2/28/2014 14:38'!addRightKid: aNode	"add the rightself  child to a node"	rightKid := aNode! !!Node methodsFor: 'kidOperation' stamp: 'YeCheng 2/28/2014 14:38'!getLeftKid	"get the left child of a node"	 ^ leftKid! !!Node methodsFor: 'kidOperation' stamp: 'YeCheng 2/28/2014 14:38'!getRightKid	"get the right child of a node"	 ^ rightKid! !!Node methodsFor: 'kidOperation' stamp: 'YeCheng 2/28/2014 14:02'!printLabel	"print the label for a node "	Transcript show: self getLabel! !!Node methodsFor: 'labelOperation' stamp: 'YeCheng 2/28/2014 12:47'!getLabel	"get the label for a node"	^label! !!Node methodsFor: 'labelOperation' stamp: 'YeCheng 2/28/2014 12:45'!setLabel: aLabel	"set a label for the node "	label := aLabel! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Node class	instanceVariableNames: ''!!Node class methodsFor: 'as yet unclassified' stamp: 'YeCheng 2/28/2014 13:23'!new: aLabel	"make a new node"		^super new	setLabel: aLabel! !